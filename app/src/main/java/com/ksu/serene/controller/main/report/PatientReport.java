package com.ksu.serene.controller.main.report;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.ArrayList;
import java.util.concurrent.TimeUnit;

import android.annotation.SuppressLint;
import android.content.Intent;
import android.os.Bundle;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.TextView;

import com.bumptech.glide.Glide;


import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;


import com.google.android.gms.tasks.OnCompleteListener;
import com.google.android.gms.tasks.OnFailureListener;
import com.google.android.gms.tasks.OnSuccessListener;
import com.google.android.gms.tasks.Task;
import com.google.firebase.Timestamp;
import com.google.firebase.auth.FirebaseAuth;

import com.google.firebase.firestore.DocumentSnapshot;
import com.google.firebase.firestore.FirebaseFirestore;
import com.google.firebase.firestore.Query;
import com.google.firebase.firestore.QueryDocumentSnapshot;
import com.google.firebase.firestore.QuerySnapshot;
import com.google.maps.android.heatmaps.WeightedLatLng;
import com.google.android.gms.maps.model.LatLng;
import com.ksu.serene.controller.Constants;
import com.ksu.serene.model.Location;
import com.ksu.serene.R;

public class PatientReport extends AppCompatActivity {

    private FirebaseAuth mAuth;
    private String userId;
    public FirebaseFirestore firebaseFirestore = FirebaseFirestore.getInstance();

    private TextView noResult;
    private String duration;
    private Button generate_report_btn;
    private String startDate;
    private String endDate;

    // Upper
    private ImageView ALGraph ;
    private TextView reportDuration;
    private ImageView backBtn;


    // Locations
    private RecyclerView locationRecyclerView;
    private locationsAdapter locationAdapter;
    private ArrayList<Location> highLocations;
    public static ArrayList<WeightedLatLng> locations;
    private Button showHeatmap;


    // Recommendation
    private TextView sleepRecommendTV, sleepAvg, sleepRcmnd, noSleepRcmnd,downSleepAvg1,downSleepAvg2;
    private TextView stepsRecommendTV, stepsAvg, stepsRcmnd, noStepsRcmnd,downStepsAvg1,downStepsAvg2;
    private View v1,v2;


    // Print & Share
    private ImageView threeDots;
    private ReportOptions reportOptions;
    private RecyclerView optionsRV;
    private LinearLayout outsideOptions;
    private String[] options = {"Print", "Share"};


    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.patient_report);

        getSupportActionBar().hide();

        // Change status bar color
        Window window = this.getWindow();
        window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
        window.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
        window.setStatusBarColor(this.getResources().getColor(R.color.darkAccent));


        // get Duration
        getExtras();

        init();
        userId = mAuth.getCurrentUser().getUid();

        // bring the info of the report which generated by the server side
        // this includes AL graph & recommendation
        lastGeneratedPatientReport();

        // location analysis & heatmap
        location();

    }//onCreate

    private void init (){
        mAuth = FirebaseAuth.getInstance();
        ALGraph = findViewById(R.id.AL_graph);

        noResult = findViewById(R.id.noResult);

        reportDuration = findViewById(R.id.reportDuration);
        reportDuration.setText(reportDate());
        locationRecyclerView = findViewById(R.id.recycleView);

        backBtn = findViewById(R.id.backButton);
        backBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                finish();
            }
        });


        showHeatmap = findViewById(R.id.heatmap);
        showHeatmap.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                heatmapActivity();
            }
        });


        sleepRecommendTV = findViewById(R.id.recommendSleep);
        sleepAvg = findViewById(R.id.averageSleepN);
        sleepRcmnd = findViewById(R.id.recommendSleepN);
        noSleepRcmnd = findViewById(R.id.noResultSleep);

        stepsRecommendTV = findViewById(R.id.recommendSteps);
        stepsAvg = findViewById(R.id.averageStepsN);
        stepsRcmnd = findViewById(R.id.recommendStepsN);
        noStepsRcmnd = findViewById(R.id.noResultSteps);

        v1 = findViewById(R.id.viewV1);
        v2 = findViewById(R.id.viewV2);

        downSleepAvg1 = findViewById(R.id.averageSleepD);
        downSleepAvg2 = findViewById(R.id.recommendSleepD);

        downStepsAvg1 = findViewById(R.id.averageStepsD);
        downStepsAvg2 = findViewById(R.id.recommendStepsD);

        // Three dots options SHARE & PRINT
        threeDots = findViewById(R.id.more);
        optionsRV = findViewById(R.id.options_list);
        outsideOptions = findViewById(R.id.outside_options);
        optionsRV.setLayoutManager(new LinearLayoutManager(this));
        reportOptions = new ReportOptions(this, options);
        optionsRV.setAdapter(reportOptions);

        threeDots.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                //options list --> visibility = true
                optionsRV.setVisibility(View.VISIBLE);
                outsideOptions.setVisibility(View.VISIBLE);
                reportOptions.updateView();
            }
        });

        outsideOptions.setOnClickListener(new View.OnClickListener(){
            @Override
            public void onClick(View v){
                optionsRV.setVisibility(View.GONE);
                outsideOptions.setVisibility(View.GONE);
            }
        });


    }

    private String reportDate() {

        String interval;

        Date startD, endD;
        String start="", end="";


        DateFormat dateFormat = new SimpleDateFormat("d MMM");

        Calendar cale = Calendar.getInstance();
        cale.add(Calendar.DATE, -1);
//        endD = cal.getTime();
        end = dateFormat.format(cale.getTime());

        Calendar cal = Calendar.getInstance();

        switch(duration){
            case "2week":

                cal.add(Calendar.DATE, -14);
                startD = cal.getTime();
                start = dateFormat.format(startD);

                break;

            case "month":

                cal.add(Calendar.MONTH, -1);
                startD = cal.getTime();
                start = dateFormat.format(startD);

                break;

            case "custom":
                SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
                Date startDate1 = null, endDate1 = null;
                try {
                    startDate1 = formatter.parse(startDate);
                    startDate1.setMonth(startDate1.getMonth()+1);

                    endDate1 = formatter.parse(endDate);
                    endDate1.setMonth(endDate1.getMonth()+1);

                } catch (ParseException e) {
                    e.printStackTrace();
                }

                start = dateFormat.format(startDate1);
                end = dateFormat.format(endDate1);//

                break;

        }//end of switch

        interval = start + " - " + end;
        return interval;

    }

    private void heatmapActivity() {

        if ( ! locations.isEmpty() )
        startActivity(new Intent(PatientReport.this, LocationHeatMap.class));

    }

    private void lastGeneratedPatientReport() {
        String doc_id = "report";
        doc_id += userId;

        firebaseFirestore.collection("LastGeneratePatientReport")
                .document(doc_id).get()
                .addOnCompleteListener(new OnCompleteListener<DocumentSnapshot>() {
                    @Override
                    public void onComplete(@NonNull Task<DocumentSnapshot> task) {
                        if (task.isSuccessful()) {

                            // The patient has only one Doc contains his report info
                            DocumentSnapshot doc = task.getResult();

                                // Get graphs
                                int numberOfGraphs = Integer.parseInt(doc.get("number_of_AL_graphs").toString());

                                if(numberOfGraphs > 0) {
                                    String img  = doc.get("AL_graph_0").toString();
                                    Glide.with(PatientReport.this)
                                            .load(img + "")
                                            .into(ALGraph);
                                }


                            recommendation(doc);

                        }//if
                    }// onComplete
                }).addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {

                    }
                });//addOnCompleteListener


    }//lastGeneratedPatientReport

    private void location() {

        highLocations = new ArrayList<Location>();
        locations = new ArrayList<WeightedLatLng>();

        locationRecyclerView.setLayoutManager(new LinearLayoutManager(this));

        firebaseFirestore.collection("PatientLocations")
                .whereEqualTo("patientID", userId)
                .get()
                .addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {
                    @SuppressLint("SetTextI18n")
                    @Override
                    public void onComplete(@NonNull Task<QuerySnapshot> task) {

                        if(task.isSuccessful()){

                            boolean locationFound = false;

                            for (QueryDocumentSnapshot document : task.getResult()) {

                                // Check for locations date if it's within selected duration

                                Date loc_date = ((Timestamp) document.get("time")).toDate();
                                Calendar cal = Calendar.getInstance();
                                cal.add(Calendar.DATE, -1);
                                Date today = cal.getTime();


                                long calcDuration = daysBetween(loc_date,today);

                                switch(duration){
                                    case "2week":
                                        if (0<calcDuration&&calcDuration<15) {
                                            locationFound = true;
                                            break; //get out of switch and proceed to save other attributes
                                        }
                                        else{
                                            locationFound = false;
                                            break;
                                        }

                                    case "month":
                                        if (0<calcDuration&&calcDuration<31){
                                            locationFound = true;
                                            break;
                                        }
                                        else{
                                            locationFound = false;
                                            break;
                                        }

                                    case "custom":
                                        SimpleDateFormat formatter = new SimpleDateFormat("dd/MM/yyyy");
                                        Date startDate1 = null, endDate1 = null;
                                        try {
                                            startDate1 = formatter.parse(startDate);
                                            startDate1.setMonth(startDate1.getMonth()+1);
                                            endDate1 = formatter.parse(endDate);
                                            endDate1.setMonth(endDate1.getMonth()+1);

                                        } catch (ParseException e) {
                                            e.printStackTrace();
                                        }

                                        if(!(loc_date.before(startDate1) || loc_date.after(endDate1))){
                                            locationFound = true;
                                            break;
                                        }
                                        else if(loc_date.getDay() == endDate1.getDay() && loc_date.getMonth() == endDate1.getMonth()){
                                            locationFound = true;
                                            break;
                                        }
                                        else{
                                            locationFound = false;
                                            break;
                                        }

                                }//end of switch

                                if (locationFound) {

                                    showHeatmap.setEnabled(true);

                                    String locationName = document.get("name").toString();
                                    double lat = (double) document.get("lat");
                                    double lng;
                                    try {
                                         lng = (double) document.get("lng");

                                    }catch (NullPointerException e){
                                         lng = (double) document.get("lon");

                                    }
                                    String anxietyLevel = "";
                                    if(document.get("anxietyLevel") != null) {
                                        anxietyLevel = document.get("anxietyLevel").toString();
                                    }

                                    String nearestLocs = "";
                                    if(document.get("nearestLoc") != null) {
                                        nearestLocs = document.get("nearestLoc").toString();
                                    }

                                    Double loc_AL = Double.parseDouble(anxietyLevel);

                                    switch (anxietyLevel){
                                        case "1" : anxietyLevel = "Low";
                                        break;

                                        case "2" : anxietyLevel = "Medium";
                                        break;

                                        case "3" : anxietyLevel = "High Anxiety";
                                        break;

                                        default: anxietyLevel = "Low";
                                        break;
                                    }


                                    int freq = 1; // for every location we assume frequency = 1

                                    // for the highest anxiety locations recycler view
                                    if ( anxietyLevel.equals("High Anxiety")) {

                                        noResult.setVisibility(View.GONE);
                                        boolean newLoc = true; // assume it is a new location

                                        for (Location hList : highLocations) { // loop on the highest location list

                                            if ( hList.getNearestLoc().equals(nearestLocs)){ // if nearby locations are equals

                                            newLoc = false; // not new locations
                                            freq = hList.getFrequency() + 1; // increment the old frequency

                                            highLocations.remove(hList); // remove the old location

                                            // update it with the new one with new frequency
                                            highLocations.add(new Location(locationName, anxietyLevel, daysBetween(loc_date, today), lat, lng, nearestLocs, freq));

                                            break;
                                            }

                                        }// end loop

                                        if(newLoc){ // add new loc with freq = 1
                                            highLocations.add(new Location(locationName, anxietyLevel, daysBetween(loc_date, today), lat, lng, nearestLocs, freq));
                                        }
                                    }


                                    // Heat map locations ( all )

                                    LatLng current = new LatLng(lat,lng);
                                    boolean found = false;
                                    //locations.add(new WeightedLatLng( current, loc_AL));

                                    for(WeightedLatLng lis : locations){

                                        if(lis.getPoint().equals(current)){
                                            if(lis.getIntensity() < loc_AL ){
                                                locations.remove(lis);
                                                locations.add(new WeightedLatLng(current, loc_AL));
                                                found = true;
                                                break;
                                            }
                                        }

                                    }

                                    if (!found){
                                        locations.add(new WeightedLatLng(current, loc_AL));
                                    }

                                }

                            }// for every location belonging to this patient (for loop)


                            locationRecyclerView.setHasFixedSize(true);
                            locationAdapter = new locationsAdapter(PatientReport.this, highLocations);
                            locationRecyclerView.setAdapter(locationAdapter);

                            if (highLocations.size() == 0){
                                locationRecyclerView.setVisibility(View.GONE);
                                noResult.setVisibility(View.VISIBLE);
                                noResult.setText(R.string.no_loc_high);
                            }else{
                                locationRecyclerView.setVisibility(View.VISIBLE);
                            }

                        }// end if

                    }// onComplete
                }).addOnFailureListener(new OnFailureListener() {
                    @Override
                    public void onFailure(@NonNull Exception e) {

                    }
                });//addOnCompleteListener

    }//location

    private static long daysBetween(Date one, Date two) {

        long diffInMillies = Math.abs(one.getTime() - two.getTime());
        long diff = TimeUnit.DAYS.convert(diffInMillies, TimeUnit.MILLISECONDS);

        return diff;

    }

    private void recommendation(DocumentSnapshot doc) {


            boolean foundSleep = false;
            boolean foundSteps = false;

            String  avgSleep ="", avgSteps ="";
            String  rcmndSleep ="", rcmndSteps = "";


                boolean sleepR = (boolean) doc.get("sleepRecomendation");
                boolean stepsR = (boolean) doc.get("stepsRecomendation");


//                // set graph
//                String url = doc.get("anxiety_level_graph").toString();
//                anxietyGraph(url);


                if(sleepR){
                    foundSleep = true;
                      avgSleep = doc.get("average_sleep_hours").toString();
                      rcmndSleep = doc.get("recommended_sleep_hours").toString();

                }

                if(stepsR){
                    foundSteps = true;
                    avgSteps = doc.get("average_steps").toString();
                    rcmndSteps = doc.get("recommended_steps").toString();
                }



            if(foundSleep){
                noSleepRcmnd.setVisibility(View.GONE);

                sleepRecommendTV.setText(R.string.sleep_rcmnd);
                // get from strings

                sleepAvg.setText(avgSleep);
                sleepRcmnd.setText(rcmndSleep);

            }else {
                sleepRecommendTV.setVisibility(View.GONE);
                sleepAvg.setVisibility(View.GONE);
                sleepRcmnd.setVisibility(View.GONE);
                downSleepAvg1.setVisibility(View.GONE);
                downSleepAvg2.setVisibility(View.GONE);
                v1.setVisibility(View.GONE);

                noSleepRcmnd.setVisibility(View.VISIBLE);
                //noSleepRcmnd.setText(R.string);

            }

            if(foundSteps){
                noStepsRcmnd.setVisibility(View.GONE);

                stepsRecommendTV.setText(R.string.steps_rcmnd);

                stepsAvg.setText(avgSteps);
                stepsRcmnd.setText(rcmndSteps);

            }else{
                stepsRecommendTV.setVisibility(View.GONE);
                stepsAvg.setVisibility(View.GONE);
                stepsRcmnd.setVisibility(View.GONE);
                downStepsAvg1.setVisibility(View.GONE);
                downStepsAvg2.setVisibility(View.GONE);
                v2.setVisibility(View.GONE);

                noStepsRcmnd.setVisibility(View.VISIBLE);
                //noStepsRcmnd.setText(R.string.good_steps);
            }


    }//recommendation+AL

    private void anxietyGraph(String url) {

        Glide.with(getApplicationContext()).load(url).into(ALGraph);

    }

    // Google Calendar
    private void events(){

    }//events

    public void getExtras() {
        Intent intent = getIntent();
        duration = intent.getExtras().getString(Constants.Keys.DURATION);

        if (duration.equals("custom")) {
            startDate = intent.getExtras().getString(Constants.Keys.START_DATE);
            endDate = intent.getExtras().getString(Constants.Keys.END_DATE);
        }
    }


}//end of class